package handler

import (
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/tuyenngduc/certificate-management-system/internal/dto/request"
	"github.com/tuyenngduc/certificate-management-system/internal/dto/response"
	"github.com/tuyenngduc/certificate-management-system/internal/service"
	"github.com/xuri/excelize/v2"
)

type SubjectHandler struct {
	subjectService            service.SubjectService
	trainingDepartmentService *service.TrainingDepartmentService
}

func NewSubjectHandler(subjectService service.SubjectService, trainingDepartmentService *service.TrainingDepartmentService) *SubjectHandler {
	return &SubjectHandler{subjectService: subjectService, trainingDepartmentService: trainingDepartmentService}
}

// POST /subjects
func (h *SubjectHandler) CreateSubject(c *gin.Context) {
	var req request.CreateSubjectRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	err := h.subjectService.CreateSubject(c.Request.Context(), &req)
	if err != nil {
		errMsg := err.Error()
		switch errMsg {
		case "m√£ m√¥n h·ªçc ƒë√£ t·ªìn t·∫°i":
			c.JSON(http.StatusConflict, gin.H{"error": errMsg})
		case "khoa kh√¥ng t·ªìn t·∫°i":
			c.JSON(http.StatusNotFound, gin.H{"error": errMsg})
		case "id khoa kh√¥ng h·ª£p l·ªá":
			c.JSON(http.StatusBadRequest, gin.H{"error": errMsg})
		default:
			c.JSON(http.StatusInternalServerError, gin.H{"error": "l·ªói h·ªá th·ªëng"})
		}
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "ƒë√£ t·∫°o m√¥n h·ªçc th√†nh c√¥ng"})
}

func (h *SubjectHandler) SearchSubjects(c *gin.Context) {
	id := c.Query("id")
	code := c.Query("code")
	name := c.Query("name")
	creditStr := c.Query("credit")

	var credit *int
	if creditStr != "" {
		val, err := strconv.Atoi(creditStr)
		if err == nil {
			credit = &val
		}
	}

	subjects, err := h.subjectService.Search(c.Request.Context(), id, code, name, credit)
	if err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}
	c.JSON(200, subjects)
}

// PUT /subjects/:id
func (h *SubjectHandler) UpdateSubject(c *gin.Context) {
	id := c.Param("id")
	var req request.UpdateSubjectRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := h.subjectService.UpdateSubject(c.Request.Context(), id, &req); err != nil {
		errMsg := err.Error()
		switch {
		case errMsg == "id m√¥n h·ªçc kh√¥ng h·ª£p l·ªá" || errMsg == "id khoa kh√¥ng h·ª£p l·ªá":
			c.JSON(http.StatusBadRequest, gin.H{"error": errMsg})
		case errMsg == "m√¥n h·ªçc kh√¥ng t·ªìn t·∫°i" || errMsg == "khoa kh√¥ng t·ªìn t·∫°i":
			c.JSON(http.StatusNotFound, gin.H{"error": errMsg})
		case errMsg == "m√£ m√¥n h·ªçc ƒë√£ t·ªìn t·∫°i":
			c.JSON(http.StatusConflict, gin.H{"error": errMsg}) // üëà Th√™m d√≤ng n√†y
		case errMsg == "kh√¥ng c√≥ d·ªØ li·ªáu c·∫≠p nh·∫≠t":
			c.JSON(http.StatusBadRequest, gin.H{"error": errMsg})
		default:
			c.JSON(http.StatusInternalServerError, gin.H{"error": "l·ªói h·ªá th·ªëng"})
		}
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "ƒë√£ c·∫≠p nh·∫≠t m√¥n h·ªçc th√†nh c√¥ng"})
}

// DELETE /subjects/:id
func (h *SubjectHandler) DeleteSubject(c *gin.Context) {
	id := c.Param("id")
	if err := h.subjectService.DeleteSubject(c.Request.Context(), id); err != nil {
		errMsg := err.Error()
		switch errMsg {
		case "id m√¥n h·ªçc kh√¥ng h·ª£p l·ªá":
			c.JSON(http.StatusBadRequest, gin.H{"error": errMsg})
		case "kh√¥ng t√¨m th·∫•y m√¥n h·ªçc":
			c.JSON(http.StatusNotFound, gin.H{"error": errMsg})
		default:
			c.JSON(http.StatusInternalServerError, gin.H{"error": "l·ªói h·ªá th·ªëng"})
		}
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "ƒë√£ x√≥a m√¥n h·ªçc th√†nh c√¥ng"})
}

// GET /subjects/:id
func (h *SubjectHandler) GetSubject(c *gin.Context) {
	id := c.Param("id")
	subject, err := h.subjectService.GetSubjectByID(c.Request.Context(), id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	if subject == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "kh√¥ng t√¨m th·∫•y m√¥n h·ªçc"})
		return
	}

	// L·∫•y t√™n khoa t·ª´ FacultyID
	faculty, err := h.trainingDepartmentService.GetFacultyByID(c.Request.Context(), subject.FacultyID)
	facultyName := ""
	if err == nil && faculty != nil {
		facultyName = faculty.Name
	}

	resp := response.SubjectResponse{
		ID:          subject.ID.Hex(),
		Code:        subject.Code,
		Name:        subject.Name,
		Credit:      subject.Credit,
		FacultyID:   facultyName, // tr·∫£ v·ªÅ t√™n khoa
		Description: subject.Description,
	}

	c.JSON(http.StatusOK, resp)
}

// GET /subjects
func (h *SubjectHandler) ListSubjects(c *gin.Context) {
	subjects, err := h.subjectService.ListSubjects(c.Request.Context())
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// L·∫•y danh s√°ch khoa v√† t·∫°o map facultyID -> facultyName
	faculties, err := h.trainingDepartmentService.GetAllFaculties(c.Request.Context())
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Kh√¥ng l·∫•y ƒë∆∞·ª£c danh s√°ch khoa"})
		return
	}
	facultyMap := make(map[string]string)
	for _, f := range faculties {
		facultyMap[f.ID.Hex()] = f.Name
	}

	var result []response.SubjectResponse
	for _, s := range subjects {
		result = append(result, response.SubjectResponse{
			ID:          s.ID.Hex(),
			Code:        s.Code,
			Name:        s.Name,
			Credit:      s.Credit,
			FacultyID:   facultyMap[s.FacultyID.Hex()], // Tr·∫£ v·ªÅ t√™n khoa thay v√¨ id
			Description: s.Description,
		})
	}

	c.JSON(http.StatusOK, result)
}

func (h *SubjectHandler) ImportSubjects(c *gin.Context) {
	file, err := c.FormFile("file")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Kh√¥ng t√¨m th·∫•y file"})
		return
	}

	src, err := file.Open()
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Kh√¥ng m·ªü ƒë∆∞·ª£c file"})
		return
	}
	defer src.Close()

	f, err := excelize.OpenReader(src)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "File kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng Excel"})
		return
	}

	rows, err := f.GetRows("Sheet1")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c sheet"})
		return
	}

	type ImportResult struct {
		Row     int    `json:"row"`
		Code    string `json:"code"`
		Status  string `json:"status"`  // "success" ho·∫∑c "failed"
		Message string `json:"message"` // L√Ω do th√†nh c√¥ng/th·∫•t b·∫°i
	}

	var results []ImportResult

	for i, row := range rows {
		if i == 0 {
			continue // B·ªè qua header
		}
		result := ImportResult{
			Row:    i + 1,
			Code:   "",
			Status: "failed",
		}
		if len(row) < 4 {
			result.Message = "Thi·∫øu d·ªØ li·ªáu b·∫Øt bu·ªôc"
			results = append(results, result)
			continue
		}
		code := row[0]
		creditStr := row[2]
		credit, err := strconv.Atoi(creditStr)
		result.Code = code

		if err != nil {
			result.Message = "Credit kh√¥ng h·ª£p l·ªá"
			results = append(results, result)
			continue
		}

		req := request.CreateSubjectByExcelRequest{
			Code:        code,
			Name:        row[1],
			Credit:      credit,
			FacultyCode: row[3],
		}
		if len(row) > 4 {
			req.Description = row[4]
		}

		if err := h.subjectService.CreateSubjectByFacultyCode(c.Request.Context(), &req); err == nil {
			result.Status = "success"
			result.Message = "Th√†nh c√¥ng"
		} else {
			result.Message = err.Error()
		}
		results = append(results, result)
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Import ho√†n t·∫•t",
		"results": results,
	})
}
